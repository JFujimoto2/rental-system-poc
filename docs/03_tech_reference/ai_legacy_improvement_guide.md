# AIを活用したレガシーシステム改善ガイド（Claude Code編）

## 基本方針

> **「AIを”もう1人のエンジニア”として使う」**

1人の限界は「知識」「時間」「レビュー相手がいない」こと。AIはこの3つを補える。

-----

## 全体の流れ

```
Step 1：ソースコード解析
    ↓ 構造・依存関係・ロジックを把握
Step 2：軽いテスト作成
    ↓ 簡単なユーティリティ系から練習
Step 3：実際のテストコード作成
    ↓ 業務ロジックの特性化テスト
```

-----

## Step 1：ソースコード解析

### Claude Codeでやること

```bash
# プロジェクトのディレクトリに移動
cd /path/to/your/project

# Claude Codeを起動
claude

# 以下のような指示を出す
```

### 最初に聞くべきこと

```
このプロジェクトの構造を解析して、以下を教えて：
1. ディレクトリ構成の概要
2. 主要なパッケージと役割
3. エントリーポイント（main, Controller等）
4. 設定ファイルの場所（application.properties等）
```

```
src/main/java 以下のクラス一覧を作成して、
レイヤー別（Controller, Service, Repository, Entity等）に分類して
```

```
このプロジェクトで使われている外部ライブラリを
pom.xml（またはbuild.gradle）から抽出して一覧化して
```

### SQL/Oracle依存の把握

```
このプロジェクト内で使われているSQLを全て抽出して、
Oracle固有の構文を使っている箇所をリストアップして
```

```
ストアドプロシージャを呼び出している箇所を検索して
```

```
PL/SQLファイルがあれば、その一覧と概要を教えて
```

### 出力してもらうもの

```
解析結果を以下の形式でmarkdownにまとめて：
- プロジェクト構成図
- クラス一覧（レイヤー別）
- Oracle依存箇所リスト
- 改善優先度の提案
```

-----

## Step 2：軽いテスト作成（練習）

### 対象を選ぶ基準

```
以下の条件に合うクラスを3つ提案して：
- 外部依存が少ない（DB接続なし）
- ロジックがシンプル
- ユーティリティ系 or 値オブジェクト系
```

### テスト作成の指示

```
[クラス名] に対するJUnit 5のテストを作成して。
まずは正常系のテストケースから。
```

```
このテストを実行するのに必要な
・依存ライブラリ（pom.xmlへの追加）
・ディレクトリ構成
を教えて
```

### 実行確認

```bash
# Claude Codeから直接実行
mvn test -Dtest=XxxTest

# または
./gradlew test --tests XxxTest
```

-----

## Step 3：実際のテストコード作成（特性化テスト）

### 対象を選ぶ

```
業務ロジックを含むServiceクラスの中で、
以下の条件に合うものを提案して：
- 重要度が高い（よく使われる）
- 複雑すぎない（メソッド数5個以下）
- DB依存はあってもOK
```

### 特性化テストの作成

```
[ServiceClass]の[methodName]メソッドについて、
現在の動作を記録する特性化テストを作成して。

以下の点を考慮して：
- モックを使ってDB依存を切り離す
- 現在の戻り値をそのまま期待値にする
- エッジケースも可能な範囲で網羅
```

### DB依存がある場合

```
このServiceはRepositoryに依存している。
Mockitoを使ってRepositoryをモック化したテストを作成して。
```

または

```
H2インメモリDBを使った統合テストを作成して。
テストデータのセットアップも含めて。
```

-----

## Claude Codeの便利な使い方

### ファイル操作

```
# 特定ファイルを読み込んで解析
@src/main/java/com/example/service/OrderService.java
このクラスの責務と依存関係を説明して

# 複数ファイルを同時に
@src/main/java/com/example/service/*.java
これらのServiceクラスの関係性を図示して
```

### コード生成→即反映

```
OrderServiceTestを作成して、
src/test/java/com/example/service/ に保存して
```

### 実行とデバッグ

```
mvn test を実行して、失敗したテストがあれば原因を分析して
```

-----

## フェーズ別のAI活用法

### Phase 1：現状把握

|やること    |AI活用法                        |
|--------|-----------------------------|
|コード構造の把握|ソースを貼って「このクラスの責務を説明して」       |
|SQL解析   |複雑なSQLを貼って「このSQLが何をしているか解説して」|
|PL/SQL読解|ストアドを貼って「このプロシージャのロジックを整理して」 |
|依存関係の可視化|「このクラスが依存しているクラスを一覧化して」      |

### Phase 2：テストを書く

|やること      |AI活用法                          |
|----------|-------------------------------|
|特性化テスト作成  |「このメソッドの現在の動作を確認するJUnitテストを書いて」|
|テストケース洗い出し|「このメソッドで考えられるエッジケースは？」         |
|モック作成     |「このクラスをテストするためのモッククラスを作って」     |
|テストデータ生成  |「このテーブル構造に対するテストデータを生成して」      |

### Phase 3：リファクタリング

|やること   |AI活用法                             |
|-------|----------------------------------|
|メソッド抽出 |「この長いメソッドを責務ごとに分割して」              |
|ロジック移動 |「このPL/SQLのロジックをJavaに移植して」         |
|標準SQL化 |「このOracle固有SQLをPostgreSQL互換に書き換えて」|
|コードレビュー|「このリファクタリングで問題がないかレビューして」         |

-----

## 1人開発で守るべきルール

### 1. 小さく進める

```
1日1コミット以下の粒度で進める
    ↓
壊れてもすぐ戻れる
    ↓
心理的安全性を確保
```

### 2. 作業ログを残す

```
今日やったこと
分かったこと
次やること
```

これをAIとの会話履歴やメモに残す。1人だと「何をやったか忘れる」のが最大の敵。

### 3. 判断に迷ったらAIに壁打ち

```
「AとBどちらのアプローチがいいか、メリデメを整理して」
「この設計判断、見落としているリスクはある？」
```

1人だと独りよがりになりがち。AIを壁打ち相手にする。

-----

## 具体的な1日の流れ（例）

```
09:00 今日やることを決める（AIに相談してもOK）
09:30 対象コードを読む → 分からない部分はAIに質問
11:00 テストを書く → AIにテストコード生成を依頼
12:00 昼休み
13:00 小さなリファクタリングを実施
14:00 AIにレビューを依頼
15:00 修正・コミット
16:00 作業ログを整理
17:00 明日やることをメモして終了
```

-----

## AIが苦手なこと（自分でやる必要があること）

|領域        |理由              |
|----------|----------------|
|業務要件の理解   |ドメイン知識はあなたにしかない |
|優先順位の決定   |何から手をつけるかはビジネス判断|
|本番環境の操作   |AIは実行できない       |
|ステークホルダー調整|人間関係はあなたの仕事     |

-----

## 推奨する最初の1週間

|日    |やること                        |
|-----|----------------------------|
|1日目  |プロジェクト構造の解析、全体像の把握          |
|2日目  |Oracle依存箇所のリストアップ           |
|3日目  |軽いユーティリティクラスにテスト作成（練習）      |
|4日目  |テスト実行環境の整備（JUnit, Mockito導入）|
|5日目  |重要なServiceクラスを1つ選定、分析       |
|6-7日目|そのServiceに特性化テストを作成         |

-----

## 準備しておくもの

```
□ プロジェクトのソースコード一式
□ ビルドできる状態（mvn compile が通る）
□ Claude Code インストール済み
□ JDKのバージョン確認（プロジェクトと合わせる）
```

-----

## おすすめツール構成

```
エディタ：VS Code + GitHub Copilot
AI相談：Claude Code（複雑な相談・設計判断）
バージョン管理：Git（SVNから移行できればベスト）
テスト：JUnit 5
ビルド：Maven or Gradle
```

-----

## レガシーコード改善ガイドとの対応

Michael Feathersの『レガシーコード改善ガイド』の概念との対応：

|本書の概念        |今回のアプローチ          |
|-------------|------------------|
|特性化テスト       |現状の挙動をテストで固定      |
|シーム          |モックを使って依存を切り離す    |
|Sprout Method|Java側にロジックを少しずつ寄せる|
|変更ポイントと影響範囲  |AIに影響範囲を分析させる     |


> **「レガシーコードとの戦いは、テストを増やしていく戦いである」**

一度にすべてを直そうとせず、触る部分だけテストで保護し、少しずつ改善していく。